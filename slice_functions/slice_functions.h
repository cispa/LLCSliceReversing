#ifndef SLICE_FUNCTIONS_H
#define SLICE_FUNCTIONS_H

#include <assert.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>

#ifndef constant
#ifdef __cplusplus
#define constant constexpr
#else
#define constant const
#endif
#endif

#define _B(x, pos) (((x) >> (pos)) & 1)

typedef int (*hash_fn_t)(uint64_t);

typedef struct {
  hash_fn_t func;
  const char *name;
} hash_function_t;

/* ==================== Linear Functions =================== */

// Generated by gen_linear.py

constant static int L_6a(unsigned long x) {
  return +_B(x, 6) ^ _B(x, 10) ^ _B(x, 12) ^ _B(x, 14) ^ _B(x, 16) ^ _B(x, 17) ^
         _B(x, 18) ^ _B(x, 20) ^ _B(x, 22) ^ _B(x, 24) ^ _B(x, 25) ^ _B(x, 26) ^
         _B(x, 27) ^ _B(x, 28) ^ _B(x, 30) ^ _B(x, 32) ^ _B(x, 33) ^ _B(x, 35) ^
         _B(x, 36);
}
constant static int L_6b(unsigned long x) {
  return +_B(x, 6) ^ _B(x, 8) ^ _B(x, 9) ^ _B(x, 10) ^ _B(x, 14) ^ _B(x, 15) ^
         _B(x, 17) ^ _B(x, 18) ^ _B(x, 20) ^ _B(x, 23) ^ _B(x, 27) ^ _B(x, 30) ^
         _B(x, 31) ^ _B(x, 34) ^ _B(x, 36) ^ _B(x, 38);
}
constant static int L_6c(unsigned long x) {
  return +_B(x, 6) ^ _B(x, 11) ^ _B(x, 12) ^ _B(x, 16) ^ _B(x, 18) ^ _B(x, 21) ^
         _B(x, 22) ^ _B(x, 23) ^ _B(x, 24) ^ _B(x, 26) ^ _B(x, 30) ^ _B(x, 31) ^
         _B(x, 32) ^ _B(x, 35) ^ _B(x, 38);
}
constant static int L_6d(unsigned long x) {
  return +_B(x, 6) ^ _B(x, 7) ^ _B(x, 8) ^ _B(x, 9) ^ _B(x, 10) ^ _B(x, 12) ^
         _B(x, 13) ^ _B(x, 14) ^ _B(x, 15) ^ _B(x, 18) ^ _B(x, 19) ^ _B(x, 20) ^
         _B(x, 22) ^ _B(x, 24) ^ _B(x, 25) ^ _B(x, 30) ^ _B(x, 32) ^ _B(x, 33) ^
         _B(x, 34) ^ _B(x, 38);
}
constant static int L_6e(unsigned long x) {
  return +_B(x, 6) ^ _B(x, 9) ^ _B(x, 11) ^ _B(x, 17) ^ _B(x, 18) ^ _B(x, 19) ^
         _B(x, 24) ^ _B(x, 25) ^ _B(x, 27) ^ _B(x, 29) ^ _B(x, 30) ^ _B(x, 35) ^
         _B(x, 36) ^ _B(x, 37);
}
constant static int L_6f(unsigned long x) {
  return +_B(x, 6) ^ _B(x, 7) ^ _B(x, 8) ^ _B(x, 12) ^ _B(x, 16) ^ _B(x, 17) ^
         _B(x, 20) ^ _B(x, 21) ^ _B(x, 22) ^ _B(x, 23) ^ _B(x, 24) ^ _B(x, 25) ^
         _B(x, 26) ^ _B(x, 28) ^ _B(x, 30) ^ _B(x, 33) ^ _B(x, 35);
}
constant static int L_6h(unsigned long x) {
  return +_B(x, 6) ^ _B(x, 7) ^ _B(x, 11) ^ _B(x, 13) ^ _B(x, 16) ^ _B(x, 17) ^
         _B(x, 18) ^ _B(x, 19) ^ _B(x, 21) ^ _B(x, 25) ^ _B(x, 26) ^ _B(x, 27) ^
         _B(x, 30) ^ _B(x, 33) ^ _B(x, 35) ^ _B(x, 36);
}
constant static int L_7a(unsigned long x) {
  return +_B(x, 7) ^ _B(x, 11) ^ _B(x, 13) ^ _B(x, 15) ^ _B(x, 17) ^ _B(x, 19) ^
         _B(x, 20) ^ _B(x, 21) ^ _B(x, 22) ^ _B(x, 23) ^ _B(x, 24) ^ _B(x, 26) ^
         _B(x, 28) ^ _B(x, 29) ^ _B(x, 31) ^ _B(x, 33) ^ _B(x, 34) ^ _B(x, 35) ^
         _B(x, 37);
}
constant static int L_7b(unsigned long x) {
  return +_B(x, 7) ^ _B(x, 12) ^ _B(x, 13) ^ _B(x, 17) ^ _B(x, 19) ^ _B(x, 22) ^
         _B(x, 23) ^ _B(x, 24) ^ _B(x, 25) ^ _B(x, 27) ^ _B(x, 31) ^ _B(x, 32) ^
         _B(x, 33) ^ _B(x, 36);
}
constant static int L_7c(unsigned long x) {
  return +_B(x, 7) ^ _B(x, 8) ^ _B(x, 11) ^ _B(x, 12) ^ _B(x, 13) ^ _B(x, 19) ^
         _B(x, 22) ^ _B(x, 23) ^ _B(x, 24) ^ _B(x, 27) ^ _B(x, 31) ^ _B(x, 32) ^
         _B(x, 33) ^ _B(x, 36);
}
constant static int L_8a(unsigned long x) {
  return +_B(x, 8) ^ _B(x, 12) ^ _B(x, 13) ^ _B(x, 16) ^ _B(x, 19) ^ _B(x, 22) ^
         _B(x, 23) ^ _B(x, 26) ^ _B(x, 27) ^ _B(x, 30) ^ _B(x, 31) ^ _B(x, 34) ^
         _B(x, 35) ^ _B(x, 36) ^ _B(x, 37);
}
constant static int L_8b(unsigned long x) {
  return +_B(x, 8) ^ _B(x, 13) ^ _B(x, 14) ^ _B(x, 18) ^ _B(x, 20) ^ _B(x, 23) ^
         _B(x, 24) ^ _B(x, 25) ^ _B(x, 26) ^ _B(x, 28) ^ _B(x, 32) ^ _B(x, 33) ^
         _B(x, 34) ^ _B(x, 37);
}
constant static int L_8c(unsigned long x) {
  return +_B(x, 8) ^ _B(x, 12) ^ _B(x, 14) ^ _B(x, 16) ^ _B(x, 19) ^ _B(x, 21) ^
         _B(x, 22) ^ _B(x, 23) ^ _B(x, 27) ^ _B(x, 28) ^ _B(x, 29) ^ _B(x, 31) ^
         _B(x, 32) ^ _B(x, 38);
}
constant static int L_8d(unsigned long x) {
  return +_B(x, 8) ^ _B(x, 9) ^ _B(x, 12) ^ _B(x, 15) ^ _B(x, 16) ^ _B(x, 18) ^
         _B(x, 19) ^ _B(x, 21) ^ _B(x, 23) ^ _B(x, 25) ^ _B(x, 26) ^ _B(x, 28) ^
         _B(x, 30) ^ _B(x, 34) ^ _B(x, 35);
}
constant static int L_9a(unsigned long x) {
  return +_B(x, 9) ^ _B(x, 12) ^ _B(x, 16) ^ _B(x, 17) ^ _B(x, 19) ^ _B(x, 21) ^
         _B(x, 22) ^ _B(x, 23) ^ _B(x, 25) ^ _B(x, 26) ^ _B(x, 27) ^ _B(x, 29) ^
         _B(x, 31) ^ _B(x, 32);
}
constant static int L_9b(unsigned long x) {
  return +_B(x, 9) ^ _B(x, 11) ^ _B(x, 12) ^ _B(x, 13) ^ _B(x, 14) ^ _B(x, 17) ^
         _B(x, 19) ^ _B(x, 21) ^ _B(x, 22) ^ _B(x, 26) ^ _B(x, 27) ^ _B(x, 29) ^
         _B(x, 32);
}
constant static int L_9c(unsigned long x) {
  return +_B(x, 9) ^ _B(x, 14) ^ _B(x, 15) ^ _B(x, 19) ^ _B(x, 21) ^ _B(x, 24) ^
         _B(x, 25) ^ _B(x, 26) ^ _B(x, 27) ^ _B(x, 29) ^ _B(x, 33) ^ _B(x, 34) ^
         _B(x, 35) ^ _B(x, 38);
}
constant static int L_9d(unsigned long x) {
  return +_B(x, 9) ^ _B(x, 13) ^ _B(x, 14) ^ _B(x, 17) ^ _B(x, 18) ^ _B(x, 19) ^
         _B(x, 20) ^ _B(x, 21) ^ _B(x, 22) ^ _B(x, 23) ^ _B(x, 25) ^ _B(x, 27) ^
         _B(x, 30) ^ _B(x, 32) ^ _B(x, 36) ^ _B(x, 38);
}
constant static int L_10a(unsigned long x) {
  return +_B(x, 10) ^ _B(x, 11) ^ _B(x, 13) ^ _B(x, 16) ^ _B(x, 17) ^
         _B(x, 18) ^ _B(x, 19) ^ _B(x, 20) ^ _B(x, 21) ^ _B(x, 22) ^ _B(x, 27) ^
         _B(x, 28) ^ _B(x, 30) ^ _B(x, 31) ^ _B(x, 32) ^ _B(x, 33);
}
constant static int L_10b(unsigned long x) {
  return +_B(x, 10) ^ _B(x, 15) ^ _B(x, 16) ^ _B(x, 20) ^ _B(x, 22) ^
         _B(x, 25) ^ _B(x, 26) ^ _B(x, 27) ^ _B(x, 28) ^ _B(x, 30) ^ _B(x, 34) ^
         _B(x, 35) ^ _B(x, 36);
}
constant static int L_11a(unsigned long x) {
  return +_B(x, 11) ^ _B(x, 16) ^ _B(x, 17) ^ _B(x, 21) ^ _B(x, 23) ^
         _B(x, 26) ^ _B(x, 27) ^ _B(x, 28) ^ _B(x, 29) ^ _B(x, 31) ^ _B(x, 35) ^
         _B(x, 36) ^ _B(x, 37);
}
constant static int L_11b(unsigned long x) {
  return +_B(x, 11) ^ _B(x, 12) ^ _B(x, 15) ^ _B(x, 20) ^ _B(x, 21) ^
         _B(x, 25) ^ _B(x, 26) ^ _B(x, 27) ^ _B(x, 28) ^ _B(x, 29) ^ _B(x, 32) ^
         _B(x, 34) ^ _B(x, 35) ^ _B(x, 36) ^ _B(x, 37) ^ _B(x, 38);
}
constant static int L_12a(unsigned long x) {
  return +_B(x, 12) ^ _B(x, 14) ^ _B(x, 16) ^ _B(x, 18) ^ _B(x, 19) ^
         _B(x, 20) ^ _B(x, 22) ^ _B(x, 24) ^ _B(x, 25) ^ _B(x, 27) ^ _B(x, 28) ^
         _B(x, 30) ^ _B(x, 31) ^ _B(x, 32) ^ _B(x, 33) ^ _B(x, 35) ^ _B(x, 36) ^
         _B(x, 38);
}

const hash_function_t linear_functions[] = {
    {.func = L_6a, .name = "L_6a"},   {.func = L_6b, .name = "L_6b"},
    {.func = L_6c, .name = "L_6c"},   {.func = L_6d, .name = "L_6d"},
    {.func = L_6e, .name = "L_6e"},   {.func = L_6f, .name = "L_6f"},
    {.func = L_6h, .name = "L_6h"},   {.func = L_7a, .name = "L_7a"},
    {.func = L_7b, .name = "L_7b"},   {.func = L_7c, .name = "L_7c"},
    {.func = L_8a, .name = "L_8a"},   {.func = L_8b, .name = "L_8b"},
    {.func = L_8c, .name = "L_8c"},   {.func = L_8d, .name = "L_8d"},
    {.func = L_9a, .name = "L_9a"},   {.func = L_9b, .name = "L_9b"},
    {.func = L_9c, .name = "L_9c"},   {.func = L_9d, .name = "L_9d"},
    {.func = L_10a, .name = "L_10a"}, {.func = L_10b, .name = "L_10b"},
    {.func = L_11a, .name = "L_11a"}, {.func = L_11b, .name = "L_11b"},
    {.func = L_12a, .name = "L_12a"}};

/* ==================== Mixer Shortcuts ==================== */

static inline int s_0(uint64_t x) { return L_9c(x) & (L_10b(x) | L_11a(x)); }

static inline int s_a(uint64_t x) {
  // NOTE: this is the same as:
  // (L_7b(x) & L_9c(x)) & (L_10b(x) | L_11a(x));
  // its the left and xor and in xeon figure but in a different form
  return L_7b(x) & s_0(x);
}

static inline int s_b(uint64_t x) { return s_a(x) & (L_9d(x) ^ 1); }

static inline int s_c(uint64_t x) { return s_a(x) & (s_b(x) ^ 1); }

static inline int s_d(uint64_t x) { return L_6c(x) & (L_8b(x) | s_0(x)); }

/* ==================== Mixer Functions ==================== */

/* Mixer C2 */

static inline int mixer_c2(size_t x) { return L_6d(x) ^ (L_8c(x) & s_c(x)); }

/* Mixer C2b */

/*
int mixer_c2(unsigned long x)
{
    return L_7c(x) ^ ((L_6h(x) ^ 1) & s_d(x));
}
*/

/* Mixer C3 */

static inline int mixer_c3(size_t x) {
  int val1 = (~s_d(x) & L_7b(x)) & 1;
  return val1 | (s_d(x) << 1);
}

/* Mixer C3b */

/*
constant static unsigned char strange_thing_lab33(unsigned long x)
{
    return L_6g(x) | (L_9c(x) & (L_10b(x) | L_9e(x)));
}

constant static unsigned char mixer_c3b_h1(unsigned long x)
{
    const unsigned char x6 = strange_thing_lab33(x);
    const unsigned char x7 = L_6c(x) & x6;
    const unsigned char x8 = L_7b(x) | x7;
    const unsigned char x9 = L_8d(x) & x8;
    return x9;
}

constant static unsigned char mixer_c3b_h0(unsigned long x)
{
    return (L_8d(x) | s_d(x)) & (1 ^ mixer_c3b_h1(x));
}

int mixer_c3b(uint64_t x)
{
    return mixer_c3b_h0(x) | (mixer_c3b_h1(x) << 1);
}
*/

/* Mixer C5 */

static inline int mixer_c5(uint64_t x) {
  uint64_t val3 = s_a(x) & 1;
  uint64_t val2 = (~val3 & L_6c(x)) & 1;
  uint64_t val1 = (~val3 & L_8b(x)) & 1;
  return (val1 << 0) | (val2 << 1) | (val3 << 2);
}

/* Mixer C9 */

static inline int mixer_c9_h_2(uint64_t x) {
  int val0 = L_6e(x) & s_c(x);
  int val1 = (1 ^ s_b(x)) & (L_6c(x) ^ val0);
  assert(val1 == 0 || val1 == 1);
  return val1;
}

static inline int mixer_c9_h_1(uint64_t x) {
  int val0 = L_12a(x) & s_c(x);
  int val1 = (1 ^ s_b(x)) & (L_8b(x) ^ val0);
  assert(val1 == 0 || val1 == 1);
  return val1;
}

static inline int mixer_c9_h_0(uint64_t x) {
  int val0 = L_11b(x) & s_c(x);
  int val1 = (1 ^ s_b(x)) & (L_9d(x) ^ val0);
  assert(val1 == 0 || val1 == 1);
  return val1;
}

static inline int mixer_c9(uint64_t x) {
  return mixer_c9_h_0(x) | (mixer_c9_h_1(x) << 1) | (mixer_c9_h_2(x) << 2) |
         (s_b(x) << 3);
}

typedef struct {
  const char *name;
  hash_fn_t function;
  int bits;
} mixer_t;

const mixer_t mixers[] = {
    {.name = "C2", .function = mixer_c2, .bits = 1},
    // {.name = "C2b", .function = mixer_c2b, .bits = 1},
    {.name = "C3", .function = mixer_c3, .bits = 2},
    // {.name = "C3b", .function = mixer_c3b, .bits = 2},
    {.name = "C5", .function = mixer_c5, .bits = 3},
    {.name = "C9", .function = mixer_c9, .bits = 4},
};

/* ==================== Slice Functions ==================== */

/* Returns the slice index for a given x and number of slices. For our
 * experiments, we found that the slice functions are the same for all CPUs
 * that have the same number of slices. However, we can't guarantee that this
 * is always the case. */
static inline int compute_slice(uint64_t x, int num_slices) {
  switch (num_slices) {
  case 6:
    return L_6b(x) | (mixer_c3(x) << 1);
  case 10:
    return L_6b(x) | (mixer_c5(x) << 1);
  case 12:
    return L_6b(x) | L_9b(x) << 1 | (mixer_c3(x) << 2);
  case 18:
    return mixer_c2(x) | mixer_c9(x) << 1;
  case 20:
    return L_6b(x) | L_6f(x) << 1 | mixer_c5(x) << 2;
  case 24:
    return L_6b(x) | L_6f(x) << 1 | L_8d(x) << 2 | mixer_c3(x) << 3;
  default:
    printf("Invalid number of slices. Not implemented.\n");
    return -1;
  }
}

#endif
